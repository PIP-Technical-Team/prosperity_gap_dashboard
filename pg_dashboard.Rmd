---
title: "Prosperity Gap Dashboard"
output:
  flexdashboard::flex_dashboard:
    orientation: columns
    social: menu
    theme: paper
runtime: shiny
resource_files:
- data/CLASS.dta
- data/CLASS.dta
- data/PIPinput_country_20231002.csv
- data/PIPinput_region_20231002.csv
- data/PIPinput_survey_20231002.csv
---

```{r}
htmltools::includeHTML("custom_header.html")
```


```{r setup-packages, include=FALSE}
library("tidyverse")
library("rlang")
library("here")
library("data.table")
library("plotly")
library("flexdashboard")  
library("joyn")
library("gghighlight")
library("DT")
library("RColorBrewer")
library("highcharter")
library("ggrepel")
library("ggtext")
library("zoo")
```


```{r data-prep, include=FALSE}
# DATA  ----

## Country data
dt_country <- fread(
  here(
    "data", 
    "PIPinput_survey_20231016.csv"
  )
)
setnames(
  dt_country, 
  old = dt_country |> 
    colnames(), 
  new = c(
    "Country_code", 
    "Year", 
    "Reporting_level", 
    "Welfare_type", 
    #"Population", 
    "PG", 
    "Inequality", 
    "Mean", 
    "Mean_b40"
  )
)
# Exclude double rows
dt_country <- 
  dt_country[, 
         if (.N > 1) {
           .SD[!Reporting_level == "rural"] 
          } else {
            .SD
            }, 
         by = .(Country_code, Year, Welfare_type)
         ][, 
           if (.N > 1) {
             .SD[Reporting_level == "national"] 
             } else {
               .SD
               }, 
           by = .(Country_code, Year, Welfare_type)
           ]
dt_country <- 
  dt_country[, 
         if (.N > 1) {
           .SD[Welfare_type == "income"] 
           } else {
             .SD
             }, 
         by = .(Country_code, Year, Reporting_level)
         ]
## Region data
dt_region <- fread(
  here(
    "data", 
    "PIPinput_region_20231002.csv"
  )
)
setnames(
  dt_region, 
  old = dt_region |> 
    colnames(), 
  new = c(
    "Region_code", 
    "Year", 
    "PG", 
    "Inequality", 
    "Mean"
  )
)
## PIP data
dt_pip <- pipr::get_stats(format = "rds") |> 
  as.data.table()
# Exclude double rows
dt_pip <- 
  dt_pip[, 
         if (.N > 1) {
           .SD[!reporting_level == "rural"] 
          } else {
            .SD
            }, 
         by = .(country_name, year, welfare_type)
         ][, 
           if (.N > 1) {
             .SD[reporting_level == "national"] 
             } else {
               .SD
               }, 
           by = .(country_name, year, welfare_type)
           ]
dt_pip <- 
  dt_pip[, 
         if (.N > 1) {
           .SD[welfare_type == "income"] 
           } else {
             .SD
             }, 
         by = .(country_name, year, reporting_level)
         ]
# Data Objects ----
countries_lookup <- dt_pip[
  ,
  .(country_name, region_name, country_code, region_code),
  by = c("country_name", "country_code", "region_name", "region_code")
][, 1:4]
setnames(
  countries_lookup, 
  old = c("country_name", "country_code", "region_name", "region_code"), 
  new = c("Country_name", "Country_code", "Region_name", "Region_code")
)

survey_lookup <- dt_pip[
  , 
  .(Year = year, Country_code = country_code, Survey_comparability = survey_comparability)
]
## Add country and region names
dt_country <- joyn::merge(
  x          = dt_country, 
  y          = countries_lookup, 
  by         = c("Country_code"),
  keep       = "left",
  yvars      = TRUE
)
dt_country[
  , 
  report := NULL
]
dt_country <- joyn::merge(
  x          = dt_country, 
  y          = survey_lookup, 
  by         = c("Country_code", "Year"), 
  keep       = "left",
  yvars      = TRUE, 
  match_type = "1:1"
)
dt_country[
  , 
  report := NULL
]
dt_region <- joyn::merge(
  x          = dt_region, 
  y          = unique(countries_lookup[, .(Region_name, Region_code)]), 
  by         = c("Region_code"), 
  keep       = "left",
  yvars      = TRUE
)
dt_region[
  , 
  report := NULL
]

# Income groups
dt_class <- haven::read_dta(
  here::here("data", "CLASS.dta")
)
dt_class <- dt_class |> 
  as.data.table() |> 
  unique(
    by = c("economy", "incgroup_current")
  )
# Clean country names
dt_class[
  38, 
  economy := "Cote d'Ivoire"
]
dt_class[
  179, 
  economy := "Sao Tome and Principe"
]
dt_class[
  198, 
  economy := "Turkiye"
]
dt_country <- joyn::merge(
  x = dt_country, 
  y = dt_class, 
  by = c("Country_name = economy"), 
  keep = "left", 
  yvars = "incgroup_current"
)
dt_country[
  , 
  report := NULL
]
```

```{r impute-data, include = FALSE}


dt_imputed <- copy(dt_country)
country_combo <- unique(
  dt_imputed[
    ,
    .(Country_name, Country_code, Region_name, Region_code)
  ], 
  by = c("Country_name", "Country_code", "Region_name", "Region_code")
)

# Fill Missing ----
dt_imputed <- joyn::merge(
  y              = CJ(
    Country_name = dt_imputed$Country_name |> unique(), 
    Year         = dt_imputed$Year         |> unique()
  ),
  x              = dt_imputed, 
  by             = c("Country_name", "Year") 
)
dt_imputed[, report := NULL]
dt_imputed <- joyn::merge(
  x             = dt_imputed, 
  y             = country_combo, 
  by            = c("Country_name"),
  update_values = T 
)
dt_imputed[, report := NULL]

# Create RowTrue giving row number, and Row giving the row numbers but with missing values ----
dt_imputed[
  , 
  RowTrue := rowidv(.SD, cols = "Country_name")
]
dt_imputed[
  , 
  Row := ifelse(
    is.na(PG), NA, RowTrue
  )
]
# Look backward and forward to impute the row numbers for Row ----
dt_imputed[
  , 
  Backward := na.locf(Row, na.rm = F),
  by = Country_name
]
dt_imputed[
  , 
  Backward := ifelse(
    is.na(Backward), 1000, Backward
  )
]
dt_imputed[
  , 
  Forward := na.locf(Row, fromLast =T, na.rm = F),
  by = Country_name
]
dt_imputed[
  , 
  Forward := ifelse(
    is.na(Forward), 1000, Forward
  )
]
# Find whether Backward or Forward imputes the nearest row number ----
dt_imputed[
  , 
  `:=`(
    ImputeDirection = ifelse(
      abs(RowTrue - Backward) < abs(RowTrue - Forward), "Backward", "Forward"
    ), 
    ImputeDistance = ifelse(
      abs(RowTrue - Backward) < abs(RowTrue - Forward), abs(RowTrue - Backward) , abs(RowTrue - Forward)
    )
  )
]

# Replace X NAs with closest non-missing ----
dt_imputed[
  , 
  Reporting_level := {
    X_replace <- ifelse(
      ImputeDirection == "Forward", 
      na.locf(Reporting_level, na.rm = F, fromLast = TRUE), 
      na.locf(Reporting_level)
    )
    X_replace
  }
]
dt_imputed[
  , 
  Welfare_type := {
    X_replace <- ifelse(
      ImputeDirection == "Forward", 
      na.locf(Welfare_type, na.rm = F, fromLast = TRUE), 
      na.locf(Welfare_type)
    )
    X_replace
  }
]
dt_imputed[
  , 
  PG := {
    X_replace <- ifelse(
      ImputeDirection == "Forward", 
      na.locf(PG, na.rm = F, fromLast = TRUE), 
      na.locf(PG, na.rm = F)
    )
    X_replace
  }
]
dt_imputed[
  , 
  Inequality := {
    X_replace <- ifelse(
      ImputeDirection == "Forward", 
      na.locf(Inequality, na.rm = F, fromLast = TRUE), 
      na.locf(Inequality)
    )
    X_replace
  }
]
dt_imputed[
  , 
  Mean := {
    X_replace <- ifelse(
      ImputeDirection == "Forward", 
      na.locf(Mean, na.rm = F, fromLast = TRUE), 
      na.locf(Mean, na.rm = F)
    )
    X_replace
  }
]
dt_imputed[
  , 
  Mean_b40 := {
    X_replace <- ifelse(
      ImputeDirection == "Forward", 
      na.locf(Mean_b40, na.rm = F, fromLast = TRUE), 
      na.locf(Mean_b40, na.rm = F)
    )
    X_replace
  }
]
dt_imputed[
  , 
  Survey_comparability := {
    X_replace <- ifelse(
      ImputeDirection == "Forward", 
      na.locf(Survey_comparability, na.rm = F, fromLast = TRUE), 
      na.locf(Survey_comparability, na.rm = F)
    )
    X_replace
  }
]


```



```{r load-functions, include=FALSE}
# Source text to include on plots
source_text <- paste("Kraay ⓡ al. (2023) updated based on Poverty and Inequality Platform (version 20230919_2017)")

title_function <- function(ind){
  
  title_lookup <- c("Mean", 
                    "Mean_b40", 
                    "PG", 
                    "Inequality"
  )
  
  title_use_vec <- c(
    "Mean (daily per capita, 2017 $PPP)", 
    "Mean of bottom 40 (daily pc, 2017 $PPP)",
    "Prosperity Gap", 
    "(PG) Inequality"
  )
  
  use_title <- title_use_vec[
    which(
      title_lookup %chin% ind
    )
  ]
  
  return(use_title)
  
}

title_function2 <- function(ind){
  
  title_lookup <- c(
    "Prosperity Gap",
    "Mean", 
    "Mean - Bottom 40", 
    "Inequality"
  )
  
  title_use_vec <- c(
    "Prosperity Gap",
    "Mean (daily per capita, 2017 $PPP)", 
    "Mean of bottom 40 (daily pc, 2017 $PPP)", 
    "(PG) Inequality"
  )
  
  use_title <- title_use_vec[
    which(
      title_lookup %chin% ind
    )
  ]
  
  return(use_title)
  
}




              

# Add Download button
downloadButtonRmd <- function (outputId, label = "Download", class = NULL, ...)  {
     tags$a(id = outputId, class = paste("btn btn-default shiny-download-link", 
        class), href = "", target = "_blank", download = NA, 
        icon("download"), label, ...)
 }

# create_data_imputed_by_countries_two_years_pg(dt = dt_country, countries_selected = countries_selected, year1_selected = 1998, year2_selected = 2005, indicator = indicator)
create_data_imputed_by_countries_two_years_pg <- function(
    dt = dt_country, 
    countries_selected  = c("South Africa", "Colombia", "United States"), 
    year1_selected      = 1998, 
    year2_selected      = 2005,
    indicator           = c("Prosperity Gap"), 
    window_length       = 2 
){
  dt_use <- copy(dt)
  
  # Change the indicator values
  if(!indicator %chin% c("PG", "Mean_b40", "Mean", "Inequality")){
    
    indicator <- switch(
      indicator, 
      "Prosperity Gap"   = "PG", 
      "Mean - Bottom 40" = "Mean_b40", 
      "Mean"             = "Mean", 
      "Inequality"       = "Inequality"
    )
  }
  
  dt1 <- dt_use[
    Year == year1_selected
  ]
  
  setnames(
    dt1, 
    old = c(indicator,    "ImputeDistance",  "ImputeDirection"), 
    new = c("Indicator1", "ImputeYears1",    "Impute_Forward1")
  )
  dt1 <- dt1[, .(Country_name, Year, Indicator1, ImputeYears1, Impute_Forward1, Survey_comparability)]
  
  dt2 <- dt_use[
    Year == year2_selected
  ]
  
  setnames(
    dt2,  
    old = c(indicator,    "ImputeDistance",  "ImputeDirection"), 
    new = c("Indicator2", "ImputeYears2",    "Impute_Forward2")
  )
  dt2 <- dt2[, .(Country_name, Year, Indicator2, ImputeYears2, Impute_Forward2, Region_name, Survey_comparability)]
  
  # Join the two years
  dt_use <- joyn::merge(
    dt1, 
    dt2, 
    keep = "inner", 
    match_type = "1:1", 
    by = c("Country_name", "Survey_comparability")
  )
  
  # Find the change in indicator
  dt_use[, report:=NULL]
  dt_use[, Change := Indicator2-Indicator1]
  dt_use[, ChangeColor := ifelse(Change>0, "Increase", "Decrease")]
  dt_use[
    Impute_Forward1 == "Forward" & Impute_Forward2 == "Forward", # both forward imputed, or not imputed at all
    ChangeYears := {
      year2_selected - year1_selected - ImputeYears1 + ImputeYears2
    }
  ]
  dt_use[
    Impute_Forward1 == "Backward" & Impute_Forward2 == "Forward", # first backward imputed, second forward
    ChangeYears := {
      year2_selected - year1_selected + ImputeYears1 + ImputeYears2
    }
  ]
  dt_use[
    Impute_Forward1 == "Forward" & Impute_Forward2 == "Backward", # first forward imputed, second backward
    ChangeYears := {
      year2_selected - year1_selected - ImputeYears1 - ImputeYears2
    }
  ]
  dt_use[
    Impute_Forward1 == "Backward" & Impute_Forward2 == "Backward", # both backward imputed
    ChangeYears := {
      year2_selected - year1_selected + ImputeYears1 - ImputeYears2
    }
  ]
  dt_use[, AnnualizedChange := Change/ChangeYears]
  dt_use[, Change := abs(Change)]
  dt_use[, Country_name := factor(Country_name, levels = Country_name[order(Indicator1)])]
  dt_use[
    is.nan(AnnualizedChange), 
    AnnualizedChange := 0
  ]
  #dt_use <- na.omit(dt_use)
  
  # Define tooltip
  dt_use[
    , 
    text_tooltip := 
      paste0(
        "Economy: ", Country_name, "\n",
        "Region: ", Region_name, "\n", 
        "Initial Value: ", round(Indicator1, 2), "\n", 
        "Annualized Change: ", round(AnnualizedChange, 2)
      )
  ]
  
  # Return
  return(dt_use)
  
}




```






Trends {#tab_trends}
===========================================================



Sidebar {.sidebar data-width=250}
-----------------------------------------------------------------------

```{r}
# Select Indicator
selectInput("indicator_trend1", 
            label = "Indicator on y-axis of Figure 1",
            choices = c(
              "Prosperity Gap", 
              "Mean", 
              "Mean - Bottom 40", 
              "Inequality" 
             ),
            selected = "Prosperity Gap")

# Select Indicator
selectInput("indicator_trend2", 
            label = "Indicator on y-axis of Figure 2",
            choices = c(
              "Prosperity Gap",
              "Mean", 
              "Mean - Bottom 40", 
              "Inequality"
            ),
            selected = "Mean")

# Select region for scatter plot to highlight
selectInput("countries_selected_trend",
            label    = "Select economies to plot",
            choices  = c(
              dt_region$Region_name |> unique() |> sort(),  # region names 
              dt_country$Country_name |> unique() |> sort() # country names
            ),
            selected = c("Colombia", "Ghana", "Thailand"),
            multiple = TRUE)

# Select Region
selectInput("region_selected_trend",
            label    = "Select regional aggregates",
            choices  = c(
              dt_region$Region_name |> unique() |> sort()  # region names
            ),
            selected = c("None"),
            multiple = TRUE)


checkboxInput("log_y_3_fig1", 
              label = "Log Y axis in Figure 1",  
              value = FALSE)

checkboxInput("log_y_3_fig2", 
              label = "Log Y axis in Figure 2",  
              value = FALSE)

# Plot single region aggregate or 
radioButtons("all_years_plot", 
                   label = "Select years to plot",  
                   choices = c(
                     "All", 
                     "Custom"
                   ), 
                   selected = c("All"))

conditionalPanel(
  condition = "input.all_years_plot == 'Custom'",
  selectInput("select_initial_year_plot", 
              label = "Initial Year:",
              choices = dt_country$Year |> 
                unique() |> 
                sort(),
              selected = dt_country$Year |> 
                min(), 
              multiple = FALSE)
)

conditionalPanel(
  condition = "input.all_years_plot == 'Custom'",
  selectInput("select_final_year_plot", 
              label = "Final Year:",
              choices = dt_country$Year |> 
                unique() |> 
                sort(),
              selected = dt_country$Year |> 
                max(), 
              multiple = FALSE)
)

observeEvent(input$select_initial_year_plot, 
             {
               updated_choices <- dt_country[
                 Year > as.numeric(input$select_initial_year_plot), 
                 unique(Year)
               ]
               updated_choices <- sort(updated_choices)
               updateSelectInput(
                 session, 
                 "select_final_year_plot", 
                 choices = updated_choices, 
                 selected = dt_country$Year |> max() 
               )
})

```


```{r}
dt_trend_plot1 <- reactive({


  # Copy data table
  dt_trend_plot1 <- copy(dt_country)

  if(input$all_years_plot == "Custom"){

    dt_trend_plot1 <- dt_trend_plot1[
      Year >= input$select_initial_year_plot &
        Year <= input$select_final_year_plot
    ]


  }

  # Filter for selected countries
  dt_trend_plot1 <- dt_trend_plot1[
     Country_name %chin% input$countries_selected_trend | Region_name %chin% input$countries_selected_trend
  ]

  # get dt's names for indicators
    indicator_trend1 <- input$indicator_trend1
    if(!indicator_trend1 %chin% c("PG", "Mean_b40", "Mean", "Inequality")){
    indicator_trend1 <- switch(
      indicator_trend1,
      "Prosperity Gap"   = "PG",
      "Mean - Bottom 40" = "Mean_b40",
      "Mean"             = "Mean",
      "Inequality"       = "Inequality"
    )
    }
setnames(
  dt_trend_plot1, 
  old = c(indicator_trend1), 
  new = c("IndicatorTrend1")
)


  dt_trend_plot1



})


dt_trend_plot2 <- reactive({

  # Copy data table
  dt_trend_plot2 <- copy(dt_country)

  if(input$all_years_plot == "Custom"){

    dt_trend_plot2 <- dt_trend_plot2[
      Year >= input$select_initial_year_plot &
        Year <= input$select_final_year_plot
    ]


  }

  # Filter for selected countries
  dt_trend_plot2 <- dt_trend_plot2[
     Country_name %chin% input$countries_selected_trend | Region_name %chin% input$countries_selected_trend
  ]

  # get dt's names for indicators
    indicator_trend2 <- input$indicator_trend2
    if(!indicator_trend2 %chin% c("PG", "Mean_b40", "Mean", "Inequality")){
    indicator_trend2 <- switch(
      indicator_trend2,
      "Prosperity Gap"   = "PG",
      "Mean - Bottom 40" = "Mean_b40",
      "Mean"             = "Mean",
      "Inequality"       = "Inequality"
    )
    }
setnames(
  dt_trend_plot2, 
  old = c(indicator_trend2), 
  new = c("IndicatorTrend2")
)


  dt_trend_plot2




})

```



Column {.tabset .tabset-fade}
-----------------------------------------------------------------------

### 




```{r}
renderPlotly({
  
# Assuming dt_trend plot1 is a function that returns your data in data.table format
dt <- dt_trend_plot1()

  # get dt's names for indicators
    indicator_trend1 <- input$indicator_trend1
    if(!indicator_trend1 %chin% c("PG", "Mean_b40", "Mean", "Inequality")){
    indicator_trend1 <- switch(
      indicator_trend1,
      "Prosperity Gap"   = "PG",
      "Mean - Bottom 40" = "Mean_b40",
      "Mean"             = "Mean",
      "Inequality"       = "Inequality"
    )
    }


# Create a subset with only the first points for each country
dt[, rel_nudge_y := 0.1 * (max(IndicatorTrend1) - min(IndicatorTrend1)), by = Country_name]
first_points = dt[, .SD[which.min(Year)], by = Country_name]
first_points = first_points[dt, on = .(Country_name), nomatch = 0]

# Create tooltip variable
dt[
  ,
  text_tooltip := (
    paste0(
      "Economy: "                     , Country_name, "\n",
      "Year: "                        , Year,
      "\n", input$indicator_trend1, ": "    , round(IndicatorTrend1, 2)
    )
  )
]

# Initialize ggplot object
tp1 <- ggplot(dt) +
  theme_classic() +
  theme(legend.position = "none")

# Conditional logic for log transformation
if(input$log_y_3_fig1 == TRUE){
  transformation <- function(x) log(x)
} else {
  transformation <- function(x) x
}

# Add geom_point and geom_line
tp1 <- tp1 +
  geom_line(aes(x = round(Year),
                y = transformation(IndicatorTrend1),
                color = Country_name
                ,group = Survey_comparability
                ), alpha = 0.8)  +
  geom_point(aes(x = round(Year), y = transformation(IndicatorTrend1), color = Country_name, text = text_tooltip), size = 2, alpha = 0.9) +
  scale_x_continuous(expand = expand_scale(mult = c(0.1, 0.1)))+
  scale_color_brewer(palette = "Dark2")

# Add geom_text for labeling the first point for each country
tp1 <- # Add geom_text for labeling the first point for each country
tp1 <- tp1 +
  geom_text(data = first_points,
            aes(x = Year, y = transformation(IndicatorTrend1 - rel_nudge_y), label = Country_name, color = Country_name),
            size = 2.5)

if(input$log_y_3_fig1 == TRUE){
  tp1 <- tp1 +
  scale_y_log10(labels = function(x) round(exp(x), 0))
}

dt_trend_plotly <- ggplotly(tp1, tooltip = "text")



dt_trend_plotly <- dt_trend_plotly |>
layout(
  # images = list(
  #   list(
  #     source = base64enc::dataURI(file = "Logo/logo_horizontal.png"),
  #         xref = "paper",
  #        yref = "paper",
  #        x= 0.8,
  #        y= -0.075,
  #        sizex = 0.15,
  #        sizey = 0.15,
  #        opacity = 0.8
  #   )),
    annotations =
              list(
                x = 0,
                y = -0.1,
                text = source_text,
                showarrow = F,
                xref='paper',
                yref='paper',
                font=list(size=6, color="grey")
                ))

dt_trend_plotly <- layout(dt_trend_plotly,
            title = list(
              text = paste("Figure 1:", title_function(indicator_trend1), "over time"),
              titlefont = list(
                size = 14
              )
              ),
            titlefont = list(
              color = 'black',
              size  = 14
            ),
            xaxis = list(
              title = ""
            ),
            yaxis = list(
              title = title_function(indicator_trend1),
              titlefont = list(size  = 12)
            )
)

dt_trend_plotly

  
  
})
```









Column {.tabset .tabset}
-----------------------------------------------------------------------



### 



```{r}
renderPlotly({
# Assuming dt_trend plot1 is a function that returns your data in data.table format
dt <- dt_trend_plot2()

  # get dt's names for indicators
    indicator_trend2 <- input$indicator_trend2
    if(!indicator_trend2 %chin% c("PG", "Mean_b40", "Mean", "Inequality")){
    indicator_trend2 <- switch(
      indicator_trend2,
      "Prosperity Gap"   = "PG",
      "Mean - Bottom 40" = "Mean_b40",
      "Mean"             = "Mean",
      "Inequality"       = "Inequality"
    )
    }


# Create a subset with only the first points for each country
dt[, rel_nudge_y := 0.1 * (max(IndicatorTrend2) - min(IndicatorTrend2)), by = Country_name]
first_points = dt[, .SD[which.min(Year)], by = Country_name]
first_points = first_points[dt, on = .(Country_name), nomatch = 0]

# Create tooltip variable
dt[
  ,
  text_tooltip := (
    paste0(
      "Economy: "                     , Country_name, "\n",
      "Year: "                        , Year,
      "\n", input$indicator_trend2, ": "    , round(IndicatorTrend2, 2)
    )
  )
]

# Initialize ggplot object
tp1 <- ggplot(dt) +
  theme_classic() +
  theme(legend.position = "none")

# Conditional logic for log transformation
if(input$log_y_3_fig2 == TRUE){
  transformation <- function(x) log(x)
} else {
  transformation <- function(x) x
}

# Add geom_point and geom_line
tp1 <- tp1 +
  geom_line(aes(x = round(Year),
                y = transformation(IndicatorTrend2),
                color = Country_name
                ,group = Survey_comparability
                ), alpha = 0.8)  +
  geom_point(aes(x = round(Year), y = transformation(IndicatorTrend2), color = Country_name, text = text_tooltip), size = 2, alpha = 0.9) +
  scale_x_continuous(expand = expand_scale(mult = c(0.1, 0.1)))+
  scale_color_brewer(palette = "Dark2")

# Add geom_text for labeling the first point for each country
tp1 <- # Add geom_text for labeling the first point for each country
tp1 <- tp1 +
  geom_text(data = first_points,
            aes(x = Year, y = transformation(IndicatorTrend2 - rel_nudge_y), label = Country_name, color = Country_name),
            size = 2.5)

if(input$log_y_3_fig2 == TRUE){
  tp1 <- tp1 +
  scale_y_log10(labels = function(x) round(exp(x), 0))
}

dt_trend_plotly <- ggplotly(tp1, tooltip = "text")



dt_trend_plotly <- dt_trend_plotly |>
layout(
  # images = list(
  #   list(
  #     source = base64enc::dataURI(file = "Logo/logo_horizontal.png"),
  #         xref = "paper",
  #        yref = "paper",
  #        x= 0.8,
  #        y= -0.075,
  #        sizex = 0.15,
  #        sizey = 0.15,
  #        opacity = 0.8
  #   )),
    annotations =
              list(
                x = 0,
                y = -0.1,
                text = source_text,
                showarrow = F,
                xref='paper',
                yref='paper',
                font=list(size=6, color="grey")
                ))

dt_trend_plotly <- layout(dt_trend_plotly,
            title = list(
              text = paste("Figure 2:", title_function(indicator_trend2), "over time"),
              titlefont = list(
                size = 14
              )
              ),
            titlefont = list(
              color = 'black',
              size  = 14
            ),
            xaxis = list(
              title = ""
            ),
            yaxis = list(
              title = title_function(indicator_trend2),
              titlefont = list(size  = 12)
            )
)

dt_trend_plotly




})
  
```




Change over Time
===========================================================


Sidebar {.sidebar data-width=200}
-----------------------------------------------------------------------

```{r sidebar-plot-1}

# Select initial year
selectInput("initial_year",
            label    = "Initial Year",
            choices  = dt_country$Year |> unique() |> sort(),
            selected = 2010,
            multiple = FALSE)

# Select initial year
selectInput("indicator",
            label    = "Select indicator",
            choices  = c(
              "Prosperity Gap", 
              "Mean - Bottom 40", 
              "Mean", 
              "Inequality"
            ),
            selected = "Prosperity Gap",
            multiple = FALSE)


# Select initial year
sliderInput("interval", 
             label = "Interval Length: measure the change over how many years?",
             min = 1, max = 10, value = 10, step = 1)

# Select initial year
sliderInput("window", 
             label = "Circa years window",
             min = 0, max = 5, value = 0, step = 1)

selectInput(
  "do_not_plot", 
  label    = "Remove from plot", 
  choices  = c(
    countries_lookup$Region_name |> 
      sort() |> 
      unique(), 
    countries_lookup$Country_name |> 
      sort() |> 
      unique()
  ), 
  selected = NULL,
  multiple = TRUE
)

downloadButtonRmd(
  outputId = "DownloadButtonChange", 
  label = "csv"
)

```

Column {.tabset}
-----------------------------------------------------------------------

### Chart 


```{r data-filter-1}
dt_use <- reactive({

  # Filter countries ----
  # create the list of countries to deselect
  deselected_countries <- c(
    countries_lookup[
      (Country_name %chin% input$do_not_plot)
    ]$Country_name,
    countries_lookup[
      (Region_name %chin% input$do_not_plot)
    ]$Country_name
  ) |>
    unique()
  # filter the countries
  dt_use <- dt_imputed[
    !(Country_name %chin% deselected_countries)
  ]
  # dt_use
  # Filter years ----
  dt_use <- dt_use[
    Year == as.numeric(input$initial_year) | Year == (as.numeric(input$initial_year) + as.numeric(input$interval))
  ]
  # Filter window ----
  dt_use <- dt_use[
    ImputeDistance <= as.numeric(input$window)
  ]


  # Create necessary columns ----
  dt_use <- create_data_imputed_by_countries_two_years_pg(
    dt = dt_use,
    countries_selected  = countries_lookup$Country_name |> unique(),
    year1_selected      = as.numeric(input$initial_year),
    year2_selected      = c(as.numeric(input$initial_year) + as.numeric(input$interval)),
    indicator           = input$indicator,
    window_length       = input$window
)

  dt_use
})

```



```{r}
renderPlotly({

dt1 <- dt_use()
# Initialize ggplot object
p <- ggplot(data = dt1) +
  theme_classic() +
  theme(legend.position = "none")

# Add segment layer with arrow
p <- p +
  geom_segment(
    aes(
      x     = Indicator1,
      xend  = Indicator2,
      y     = Country_name,
      yend  = Country_name,
      color = ChangeColor
    ),
    arrow = arrow(length = unit(0.5, "inches"), type = "closed"),
    alpha = 0.9
  )

# Add point layer first to avoid overlap
p <- p +
  geom_point(aes(x = Indicator1, y = Country_name, colour = ChangeColor, text = text_tooltip), size = 2,
    alpha = 0.9)



# Conditional logic for color scales
if(input$indicator %chin% c("Mean", "Mean - Bottom 40")){
  p <- p +
    scale_color_manual(values = c("Increase" = "#1b9e77", "Decrease" = "#d95f02"))
} else {
  p <- p +
    scale_color_manual(values = c("Increase" = "#d95f02", "Decrease" = "#1b9e77"))
}





# Convert to plotly object
pp <- ggplotly(p, tooltip = "text")

# pp <- pp |>
#    layout(
#      images = list(
#        list(
#          source = base64enc::dataURI(file = "Logo/logo_horizontal.png"),
#              xref = "paper",
#             yref = "paper",
#             x= 0.8,
#             y= -0.05,
#             sizex = 0.15,
#             sizey = 0.15,
#             opacity = 0.8
#        )),
#        annotations =
#                  list(
#                    x = 0,
#                    y = -0.1,
#                    text = source_text,
#                    showarrow = F,
#                    xref='paper',
#                    yref='paper',
#                    font=list(size=6, color="grey")
#                    ))

pp <- layout(pp,
            title = list(
              text = paste(
                "Change in",
                title_function2(input$indicator),
                "from circa",
                as.numeric(input$initial_year),
                "to circa",
                as.numeric(input$initial_year) + as.numeric(input$interval)
              )
            ),
            titlefont = list(
              color = 'black',
              size  = 14
            ),
            xaxis = list(
              title = title_function2(input$indicator),
              titlefont = list(size = 12)
            ),
            yaxis = list(
              title = ""
            )
)



# Display the plot
pp
})




```


### Explanation




<p style="text-align: justify;">
    This plot shows the change in the selected indicator over time for economies where there is comparable survey data in the chosen period. The <strong style="color:black">dot</strong> gives the initial indicator value for that economy. The <strong style="color:black">horizontal line segment</strong> connects the initial and final year indicator values. The <strong style="color:black">color</strong> indicates whether an economy's outcomes improve over the chosen interval. When the overall welfare mean or the mean of the bottom 40 are selected, green indicates that these measures have increased over time. For the remaining indicators, the prosperity gap and the inequality measure, an increase is shown in red. The economies on the y-axis are ordered according to the chosen indicator, where the top country has the largest indicator value in the initial year.
</p>

<strong style="color:black; text-align: justify;">What if an economy has no surveys in the chosen years?</strong>

<p style="text-align: justify;">
    Users specify the initial year (e.g., 2000) and the period over which they would like to study the change (e.g., the interval length is 5 years for looking at the 2000-2005 period).
</p>

<p style="text-align: justify;">
    Data might be missing for some economies for specific years. To increase the number of economies available, users can specify a circa year window. For example, if the chosen circa window is 2, then data 2 years either side of 2000 are considered (i.e., between 1998 and 2002). Within the circa window, data points in the initial and final years are selected with a preference for closer and newer data points: For example, if data for 2000 is missing, the algorithm will first look for data in 2001 and if 2001 data is also missing, it will then search in 1999. If both are missing, it will look for data in 2002 and 1998. An equivalent process is applied to the final year.
</p>

<p style="text-align: justify;">
    With a circa window larger than zero, the duration over which changes are measured differs across economies. For example, with an interval of 5 years and a window of 2, the duration varies between 1 year and 9 years (e.g. 2002-2003 and 1998-2007 are both permissible).
</p>





Scatterplot of Indicators
===========================================================



Sidebar {.sidebar data-width=200}
-----------------------------------------------------------------------

```{r sidebar-plot-2}
# Select Indicator
selectInput("ineq_indicatorX", 
            label = "Indicator x-axis:",
            choices = c(
              "Prosperity Gap",
              "Mean", 
              "Mean - Bottom 40", 
              "Inequality"
            ),
            selected = "Mean")

selectInput("ineq_indicatorY", 
            label = "Indicator y-axis:",
            choices = c(
              "Prosperity Gap",
              "Mean", 
              "Mean - Bottom 40", 
              "Inequality"
            ),
            selected = "Prosperity Gap")
 

selectInput("select_welfare_type", 
              label = "Survey Type:", 
              choices = c("Both", "Consumption", "Income"), 
              selected = "Both"
)

checkboxGroupInput(
  inputId  = "log_transformations", 
  label    = "Log Transformations:", 
  choices  = c("Y axis", "X axis"), 
  selected = NULL
)



selectInput("countries_selected",
            label    = "Select economies",
            choices  = c(
              "All", 
              countries_lookup$Region_name |> unique(), 
              countries_lookup$Country_name |> unique()
            ),
            selected = "All",
            multiple = TRUE)
# Select region for scatter plot to highlight
selectInput("background_regions",
            label    = "Select comparison economies",
            choices  = c(
              "All", 
              countries_lookup$Region_name |> 
                unique()
            ),
            selected = "",
            multiple = TRUE)
radioButtons("color_by", 
                   label = "Color points by:",  
                   choices = c(
                     "Region", 
                     "Income group"
                   ), 
                   selected = c("Region"))

radioButtons("all_years_scatterplot", 
                   label = "Select years to plot",  
                   choices = c(
                     "All", 
                     "Custom"
                   ), 
                   selected = c("All"))

conditionalPanel(
  condition = "input.all_years_scatterplot == 'Custom'",
  selectInput("select_initial_year_scatterplot", 
              label = "Initial Year:",
              choices = dt_country$Year |> 
                unique() |> 
                sort(),
              selected = dt_country$Year |> 
                min(), 
              multiple = FALSE)
)

conditionalPanel(
  condition = "input.all_years_scatterplot == 'Custom'",
  selectInput("select_final_year_scatterplot", 
              label = "Final Year:",
              choices = dt_country$Year |> 
                unique() |> 
                sort(),
              selected = dt_country$Year |> 
                max(), 
              multiple = FALSE)
)

observeEvent(input$select_initial_year_scatterplot, 
             {
               updated_choices <- dt_country[
                 Year > as.numeric(input$select_initial_year_scatterplot), 
                 unique(Year)
               ]
               updated_choices <- sort(updated_choices)
               updateSelectInput(
                 session, 
                 "select_final_year_scatterplot", 
                 choices = updated_choices, 
                 selected = dt_country$Year |> max() 
               )
})

```
Advanced Features:
```{r}
checkboxInput("add_line", 
              label = "Add fitted line", 
              value = FALSE)


downloadButtonRmd(
  outputId = "DownloadButtonScatterplot",
  label = "CSV"
)

```


Column {.tabset}
-----------------------------------------------------------------------

```{r data-filter2}



selected_countries <- reactive({

  # get list of selected countries
  if(c("All") %chin% input$countries_selected){

    selected_countries <- dt_country$Country_name |> unique()

  } else {

    selected_countries <- c(
    (countries_lookup[Country_name %chin% input$countries_selected])$Country_name,
    (countries_lookup[Region_name %chin% input$countries_selected])$Country_name
  ) |> unique()

  }


    # welfare
  if(!input$select_welfare_type == c("Both")){
    selected_countries <- intersect(
      selected_countries,
      dt_country[Welfare_type == tolower(input$select_welfare_type)]$Country_name
    ) |> unique()
  } else {
    selected_countries
  }
  selected_countries

})


dt_use_sp <- reactive({
  
  # Copy pip stats
  dt_use_sp <- copy(dt_country)
  
  # filter years
  if(input$all_years_scatterplot == "Custom"){

    dt_use_sp <- dt_use_sp[
     Year >= input$select_initial_year_scatterplot &
        Year <= input$select_final_year_scatterplot
    ]

  }
  
  # Filter by survey type
  if(!input$select_welfare_type =="Both"){
    dt_use_sp <- dt_use_sp[
      Welfare_type == tolower(input$select_welfare_type)
    ]
  } else{
    dt_use_sp
  }
  
  
  # Keep selected and background countries
  if(
    ! any(
      c(
        "All" %chin% input$countries_selected,
        "All" %chin% input$background_regions
      )
    )
  ){

    # which countries to keep in data
    countries_filtered <- c(
      selected_countries(),
      countries_lookup[
        Region_name %chin% input$background_regions
      ]$Country_name
    )

    # filter
    dt_use_sp <- dt_use_sp[
      Country_name %chin% countries_filtered
    ]


  }

  if(input$ineq_indicatorX == input$ineq_indicatorY) stop("Indicators chosen for x and y axes should be different")
  
  # Change names of selected indicators
    # Change the indicator values
  ineq_indic_X <- input$ineq_indicatorX
  if(!ineq_indic_X %chin% c("PG", "Mean_b40", "Mean", "Inequality")){

    ineq_indic_X <- switch(
      ineq_indic_X,
      "Prosperity Gap"   = "PG",
      "Mean - Bottom 40" = "Mean_b40",
      "Mean"             = "Mean",
      "Inequality"       = "Inequality"
    )
  }
  ineq_indic_Y <- input$ineq_indicatorY
  if(!ineq_indic_Y %chin% c("PG", "Mean_b40", "Mean", "Inequality")){

    ineq_indic_Y <- switch(
      ineq_indic_Y,
      "Prosperity Gap"   = "PG",
      "Mean - Bottom 40" = "Mean_b40",
      "Mean"             = "Mean",
      "Inequality"       = "Inequality"
    )
  }

  setnames(
    x = dt_use_sp,
    old = c(ineq_indic_X, ineq_indic_Y),
    new = c("IndicatorX", "IndicatorY")
  )

  dt_use_sp[
    ,
    `Income Group` := incgroup_current
  ]
  #factor(incgroup_current, levels = incgroup_current[order(mean)])]
  # Define tooltip
  dt_use_sp[
    ,
    text_tooltip := (
      paste0(
        "Economy: ", Country_name, "\n",
        "Region: ", Region_name,  "\n",
        "Income Group: ", incgroup_current, "\n",
        input$ineq_indicatorX, ": ", round(IndicatorX,2),  "\n",
        input$ineq_indicatorY, ": ", round(IndicatorY, 2),  "\n",
        "Survey type: ", str_to_title(Welfare_type)
      )
    )
  ]
col_vec <- c()
all_cntr <- dt_use_sp$Country_name
reg <- dt_use_sp$Region_name
inc <- dt_use_sp$incgroup_current
dt <- data.table(all_cntr = all_cntr, reg = reg)
# Conditionally define 'bla' based on the value of 'Check'
if (input$color_by == "Region") {
  dt[, col_vec := ifelse(all_cntr %chin% selected_countries(), reg, "Unselected")]
} else if (input$color_by == "Income group") {
  dt[, col_vec := ifelse(all_cntr %chin% selected_countries(), inc, "Unselected")]
}
# Extract the 'bla' column to a vector
col_vec <- dt$col_vec


# dt_use_sp <- dt_use_sp |> 
#   mutate(
#     Color = ifelse(
#       country_name %chin% selected_countries(), 
#       ifelse(
#         input$color_by == "Region", dt_use_sp$region_name, dt_use_sp$incgroup_current
#       ), 
#       "Other"
#     )
#   )
    
dt_use_sp[
  , 
  Color := col_vec
]

  dt_use_sp

    })


```

### Chart

```{r plot2}

renderPlotly({


transformation_x <- function(x){

  if("X axis" %chin% input$log_transformations){
    log(x)
  } else{
    x
  }

}

transformation_y <- function(x){

  if("Y axis" %chin% input$log_transformations){
    log(x)
  } else{
    x
  }
}
# define tooltip ----
dt <- dt_use_sp()
# Initialize ggplot object
sp1 <- ggplot(dt, aes(color = Color))

# Custom function to modify the palette
modify_palette <- function(palette_name, name_to_change, new_color) {
  palette <- brewer.pal(name = palette_name, n = length(unique(dt$Color)))
  names(palette) <- unique(dt$Color)
  palette[name_to_change] <- new_color
  return(palette)
}
# Modify the Dark2 palette to have "NOT" as light grey
modified_palette <- modify_palette("Dark2", "Unselected", "lightgrey")

sp1 <- sp1 +
  scale_color_manual(values = modified_palette, drop = TRUE)

  # scale_color_brewer(palette = "Dark2")

# # Add geom_point
# if(input$color_by == "Region"){
# Dynamically generate alpha values
unique_colors <- unique(dt$Color)
alpha_values <- setNames(rep(0.9, length(unique_colors)), unique_colors)
alpha_values["Unselected"] = 0.2

  sp1 <- sp1 +
  geom_point(aes(
    x = transformation_x(IndicatorX),
    y = transformation_y(IndicatorY),
    color = Color,
    text = text_tooltip,
    alpha = Color
  ), alpha = 0.55) +
  scale_alpha_manual(values = alpha_values) +
  guides(alpha=FALSE, color=guide_legend(override.aes=list(alpha=1)))



# Add geom_smooth if required
if (input$add_line == TRUE) {
  sp1 <- sp1 +
    geom_smooth(
      aes(
        x = transformation_x(IndicatorX),
        y = transformation_y(IndicatorY),
        stat = "smooth",
        position = "identity"
      )
    )
}

# Adjust theme
sp1 <- sp1 + theme_classic()
#
# if log transform, use original units
  if(c("X axis" %chin% input$log_transformations)){

      if(input$ineq_indicatorX == "Mean"){
        sp1 <- sp1 +
          scale_x_log10(
            labels = function(x) round(exp(x), 0),
            limits = c(log(1.1), log(94))
          )
      } else{
        sp1 <- sp1 +
          scale_x_log10(
            labels = function(x) round(exp(x), 0)
          )
      }

  }
  if(c("Y axis" %chin% input$log_transformations)){


        sp1 <- sp1 +
          scale_y_log10(
            labels = function(x) round(exp(x), 0)
          )


  }




# Convert to plotly object
sp1_plotly <- ggplotly(sp1, tooltip = "text")



# Display the plot
sp1_plotly <- sp1_plotly |>
   layout(
     # images = list(
     #   list(
     #     source = base64enc::dataURI(file = "Logo/logo_horizontal.png"),
     #         xref = "paper",
     #        yref = "paper",
     #        x= 0.8,
     #        y= -0.05,
     #        sizex = 0.15,
     #        sizey = 0.15,
     #        opacity = 0.8
     #   )),
       annotations =
                 list(
                   x = 0,
                   y = -0.08,
                   text = source_text,
                   showarrow = F,
                   xref='paper',
                   yref='paper',
                   font=list(size=6, color="grey")
                 ))


sp1_plotly <- layout(sp1_plotly,
            title = list(text = paste("Relationship between", title_function2(input$ineq_indicatorX), "and", title_function2(input$ineq_indicatorY))),
            titlefont = list(size = 14),
            xaxis = list(title = title_function2(input$ineq_indicatorX), titlefont = list(size = 12)),
            yaxis = list(
              title = title_function2(input$ineq_indicatorY),
              titlefont = list(size = 12)
            )
)


sp1_plotly


})


reactive({

dt <- dt_use_sp()
dt <- dt[
  ,
  .(Country_name, Region_name, IndicatorX, IndicatorY)
]
setnames(
  dt,
  old = c("IndicatorX", "IndicatorY"),
  new = c(ineq_indic_X, "PG")
)
output$DownloadButtonScatterplot <- downloadHandler(
  filename = function() {
    paste("prosperity-gap-scatterplot", Sys.Date(), ".csv", sep = "")
  },
  content = function(file) {
    write.csv(
      dt
      , file)
  }
)

})


```





### Explanation



<p style='text-align:justify;'>This scatterplot shows the relationship between two selected indicators. By default, it shows all data, regardless of economy, region, or whether welfare is measured by consumption or income. Making selections on the side panel will limit the display to the selected data (e.g. selecting SSA as the region and consumption as the welfare measure plots data for Sub-Saharan Africa where welfare is measured by consumption). The selected data can be compared against other economies or regions. Dots are colored by region. The chart sorts countries by PIP’s regional definition: East Asia and Pacific  (EAP), Europe and Central Asia (ECA), Latin America and the Caribbean (LAC), Middle East and North Africa (MNA), Other High Income (OHI), South Asia (SAS), Sub-Saharan Africa (SSA)</p>

<p style='text-align:justify;'>The plot provides a feature for incorporating a line to depict the underlying relationship between variables. This line represents the conditional mean, estimated via locally estimated scatterplot smoothing (LOESS), and is accompanied by 95% confidence intervals.</p>













Table of Indicators
===========================================================


Sidebar {.sidebar data-width=150}
-----------------------------------------------------------------------

```{r sidebar-table-1}

# Select Indicator
checkboxGroupInput("ineq_indicator_table", 
            label = "Indicators:",
            choices = c(
              "Prosperity Gap",
              "Mean", 
              "Mean - Bottom 40", 
              "Inequality"
            ),
            selected =  c(
              "Prosperity Gap"
            ))


selectInput("select_countries_table", 
            label = "Economies:",
            choices = c(
              "All", 
              dt_country$Region_name |> 
                unique() |> 
                sort(),  
              dt_country$Country_name |> 
                unique()|> 
                sort()
            ),
            selected = c("All"), 
            multiple = TRUE)



radioButtons("all_years_table", 
                   label = "Years shown in table",  
                   choices = c(
                     "Latest", 
                     "All", 
                     "Custom"
                   ), 
                   selected = c("Latest"))


conditionalPanel(
  condition = "input.all_years_table == 'Custom'",
  selectInput("select_initial_year_table", 
              label = "Initial Year:",
              choices = dt_country$Year |> 
                unique() |> 
                sort(),
              selected = dt_country$Year |> 
                min(), 
              multiple = FALSE)
)

conditionalPanel(
  condition = "input.all_years_table == 'Custom' && input.select_initial_year_table != null",
  selectInput("select_final_year_table", 
              label = "Final Year:",
              choices = dt_country$Year |> 
                unique() |> 
                sort(),
              selected = dt_country$Year |> 
                max(), 
              multiple = FALSE)
)

observeEvent(input$select_initial_year_table, 
             {
               updated_choices <- dt_country[
                 Year > as.numeric(input$select_initial_year_table), 
                 unique(Year)
               ]
               updated_choices <- sort(updated_choices)
               updateSelectInput(
                 session, 
                 "select_final_year_table", 
                 choices = updated_choices, 
                 selected = dt_country$Year |> max() 
               )
})


# Render download button
#downloadButton("downloadData", "Download CSV")

downloadButtonRmd(
  outputId = "DownloadButtonTable", 
  label = "CSV"
)


```




Row {.tabset .tabset-fade}
-----------------------------------------------------------------------

###

```{r plot-table}


make_table_across_countries <- function(
    dt_1,
    country_name_vec = c("Angola", "South Africa"),
    ineq_indicators,
    years_selected = c("All", "Latest", "Custom"),
    start_year = NULL,
    end_year = NULL
){
  dt <- copy(dt_country)
  # Check Inputs ----
  stopifnot(is.data.table(dt))
  stopifnot(country_name_vec %chin% countries_lookup$Country_name)
  years_selected <- match.arg(years_selected)

  # # If decile shares is selected
  # if(c("Decile Shares") %chin% ineq_indicators ){
  #   # remove "Decile Shares" element
  #   ineq_indicators <- ineq_indicators[!c("Decile Shares") == ineq_indicators]
  #   # add all individual decile shares
  #   ineq_indicators <- c(
  #     ineq_indicators,
  #     paste0("decile", 1:10)
  #   )
  # }
  # 
  # # IF the ratios selected
  # if(c("Top 10 Bottom 40 Ratio") %chin% ineq_indicators){
  #   # remove ratios elements
  #   ineq_indicators <- ineq_indicators[!c("Top 10 Bottom 40 Ratio") ==ineq_indicators]
  #   # add all individual decile shares
  #   ineq_indicators <- c(
  #     ineq_indicators,
  #     "t10_b40"
  #   )
  # }
  #   # IF the ratios selected
  # if(c("Top 20 Bottom 20 Ratio") %chin% ineq_indicators){
  #   # remove ratios elements
  #   ineq_indicators <- ineq_indicators[!c("Top 20 Bottom 20 Ratio") == ineq_indicators]
  #   # add all individual decile shares
  #   ineq_indicators <- c(
  #     ineq_indicators,
  #     "t20_b20"
  #   )
  # }

  indicators_names <- ineq_indicators
    # Convert this character vector into a data.table
dt_indicators <- data.table(ineq_indicators = ineq_indicators)
ineq_indicators <- "Prosperity Gap"
#  change each name
dt_indicators[, ineq_indicators := switch(
  ineq_indicators,
  "Prosperity Gap"   = "PG",
  "Mean - Bottom 40" = "Mean_b40",
  "Mean"             = "Mean",
  "Inequality"       = "Inequality"
), by = ineq_indicators]
ineq_indicators <- dt_indicators$ineq_indicators
# dt_indicators$ineq_indicators
# ineq_indicators
  # Prepare Data ----
  selected_cols <- c(
    "Country",
    "Region",
    "Year",
    "Level",
    "Type",
    "Spell",
    ineq_indicators
  )


  setnames(
    dt,
    old = c("Country_name", "Region_code", "Survey_comparability", "Reporting_level", "Welfare_type"),
    new = c("Country", "Region", "Spell", "Level", "Type")                           # Clean variable names
  )
  # setnames(
  #   dt,
  #   old = colnames(dt),
  #   new = stringr::str_to_title(colnames(dt))             # Capitalize column names
  # )


  dt <- dt[
    Country %chin% country_name_vec,         # filter by country
    ..selected_cols                             # Select id vars and inequality indicators
  ]

  dt[
    ,
    (names(dt)) := lapply(                       # Round to 2 decimals
      .SD,
      \(x){
        if (is.numeric(x))
          round(x, 2)
        else
          x
        }
    )
  ]


  # Filter years
  if(years_selected == "Latest"){
    dt <- dt[,
             .SD[which.max(Year)],
             by = Country]
  }
  if(years_selected == "Custom"){

    if(start_year > end_year)
      stop("Please note the initial year must be lower than the final year")
    dt <- dt[
      Year >= start_year &
        Year <= end_year
    ]

  }


  setorder(dt, Country, Region, -Year, Level, Type)

  dt # return
} # end of make_table_across_countries()



table <-
  reactive({

    # Filter countries

    ct <-
      if ("All" %chin% input$select_countries_table) {
      countries_lookup$Country_name
    } else {
      c(countries_lookup[Country_name %chin%
                                input$select_countries_table]$Country_name,
        countries_lookup[Region_name %chin%
                                input$select_countries_table]$Country_name
        ) |>
        unique()
    }

    make_table_across_countries(
      dt               = dt_pip,
      country_name_vec = ct,
      ineq_indicators  = input$ineq_indicator_table,
      years_selected   = input$all_years_table,
      start_year       = input$select_initial_year_table,
      end_year         = input$select_final_year_table
  )
})



renderPlotly({

list_of_columns <- lapply(
    names(table()),
    \(col_name) { # Make the columns list items for plotly
      return(table()[[col_name]])
    })

  # plot table
  t <- plot_ly(
    type = 'table',
    #columnwidth = c(100, 100),
    header = list(
      values = table() |>
        colnames() |>
        # column names vector
        str_replace_all(pattern = "_",
                        replacement = " "),
      align = "center",
      line = list(width = 1, color = 'black'),
      fill = list(color = c("grey", "grey")),
      font = list(family = "Arial", size = 10, color = "white")
    ),
    cells = list(
      values = list_of_columns,
      align  = c("center", "center"),
      line   = list(color = "black", width = 1),
      font   = list(family = "Arial", size = 10, color = c("black"))
    ))

t <- layout(
  t,
  title   = "Prosperity Gap, Selected Economies and Years",
  titlefont = list(color = 'black', size = 14),
  title_x = 0
)

 t <- t |>
   layout(
     # images = list(
     #   list(
     #     source = base64enc::dataURI(file = "Logo/logo_horizontal.png"),
     #         xref = "paper",
     #        yref = "paper",
     #        x= 0.8,
     #        y= -0.02,
     #        sizex = 0.15,
     #        sizey = 0.15,
     #        opacity = 0.8
     #   )),
       annotations =
                 list(
                   x = 0,
                   y = -0.05,
                   text = source_text,
                   showarrow = F,
                   xref='paper',
                   yref='paper',
                   font=list(size=8, color="grey")
                   ))

})


output$DownloadButtonTable <- downloadHandler(
  filename = function() {
    paste("prosperity-gap-table", Sys.Date(), ".csv", sep = "")
  },
  content = function(file) {
    write.csv(table(), file)
  }
)



```




Bar chart decomposition
===========================================================


Sidebar {.sidebar data-width=150}
-----------------------------------------------------------------------


```{r sidebar-barchart}

# Select Indicator
radioButtons("indicator_barchart", 
            label = "Indicator:",
            choices = c(
              "Prosperity Gap",
              # "Mean", 
              # "Mean - Bottom 40", 
              "Inequality"
            ),
            selected =  c(
              "Prosperity Gap"
            ))


radioButtons("region_or_countries", 
                   label = "Plot for regions or countries",  
                   choices = c(
                     "Regions", 
                     "Countries"
                   ), 
                   selected = c("Regions"))

conditionalPanel(
  condition = "input.region_or_countries == 'Countries'", 
  selectInput( "select_countries_barchart", 
               label    = "Select Countries", 
               choices  = c(
                 dt_country$Country_name |> 
                   unique() |> 
                   sort()
               ), 
               selected = c(
                 "Colombia", 
                 "Ghana", 
                 "Thailand", 
                 "Argentina"
               ), 
               multiple = TRUE
  )
)

conditionalPanel(
  condition = "input.region_or_countries == 'Regions'", 
  selectInput( "select_regions_barchart", 
               label    = "Select Regions", 
               choices  = c(
                 "All",
                 dt_region$Region_name |> 
                   unique() |> 
                   sort()
               ), 
               selected = c(
                 "All"
               ), 
               multiple = TRUE
  )
)


radioButtons("all_years_barchart", 
                   label = "Years selection",  
                   choices = c(
                     "All", 
                     "Custom"
                   ), 
                   selected = c("All"))


conditionalPanel(
  condition = "input.all_years_barchart == 'Custom'",
  selectInput("select_initial_year_barchart", 
              label = "Initial Year:",
              choices = dt_country$Year |> 
                unique() |> 
                sort(),
              selected = dt_country$Year |> 
                min(), 
              multiple = FALSE)
)

conditionalPanel(
  condition = "input.all_years_barchart == 'Custom' && input.all_years_barchart != null",
  selectInput("select_final_year_barchart", 
              label = "Final Year:",
              choices = dt_country$Year |> 
                unique() |> 
                sort(),
              selected = dt_country$Year |> 
                max(), 
              multiple = FALSE)
)

observeEvent(input$select_initial_year_table, 
             {
               updated_choices <- dt_country[
                 Year > as.numeric(input$select_initial_year_table), 
                 unique(Year)
               ]
               updated_choices <- sort(updated_choices)
               updateSelectInput(
                 session, 
                 "select_final_year_barchart", 
                 choices = updated_choices, 
                 selected = dt_country$Year |> max() 
               )
})


# Render download button
#downloadButton("downloadData", "Download CSV")

downloadButtonRmd(
  outputId = "DownloadButtonBarchart", 
  label = "CSV"
)


```

Column {.tabset .tabset-fade}
-----------------------------------------------------------------------


```{r data-barchart}

dt_barchart <- reactive({
  
  # Region or countries ----
  if(input$region_or_countries == "Regions"){
    dt_barchart <- copy(dt_region)
    
    # Filter
    if(!input$select_regions_barchart == "All"){
      
    dt_barchart <- dt_barchart[
      Region_name %chin% input$select_regions_barchart
    ]
    
    }
    
    setnames(
      dt_barchart,
      old = "Region_name",
      new = "Group"
    )  
    
    dt_barchart <- dt_barchart[
      !Region_code == "WLD"
    ]

    
  } else{
    dt_barchart <- copy(dt_country)
    # Filter
    dt_barchart <- dt_barchart[
      Country_name %chin% input$select_countries_barchart,
    ]
    setnames(
      dt_barchart, 
      old = "Country_name", 
      new = "Group"
    )
    
  }
  
  # Indicator name ----
    if(input$indicator_barchart == "Prosperity Gap"){
    
    indicator   <- c("PG")
    
    } else {
      indicator <- c("Inequality")
    }
  
  # Round to 2 decimal places ----
    col_round <- c("PG", "Inequality")
    dt_barchart[
      ,
      (col_round) := lapply(
        .SD,
        function(x) round(x, 2)
      ),
      .SDcols = col_round
    ]

  # Set indicator ----
  setnames(
    dt_barchart, 
    new = "Indicator", 
    old = indicator
  )
  
   # Filter years ----
  if(input$all_years_barchart == "Custom"){
    
    dt_barchart <- dt_barchart[
      Year >= as.numeric(input$select_initial_year_barchart) & Year <= as.numeric(input$select_final_year_barchart)
    ]
    
  } else{
    dt_barchart
  }
  
  
  
})

```


```{r plot-barchart}

# renderTable({
#   dt_barchart()
# })
renderHighchart({


  dt <- dt_barchart()
  # Create stacked bar chart
hchart(
  dt,
  type = "column",
  hcaes(x = Year, y = Indicator, group = Group)
  ) |>
  hc_plotOptions(column = list(stacking = "normal")) |>
  hc_yAxis(title = list(text = title_function2(input$indicator_barchart))) |>
  hc_xAxis(categories = unique(dt$Year)) |>
  hc_legend(reverse = TRUE)


})



```



About and Definitions {#tab_about}
===========================================================

Column {.tabset}
-----------------------------------------------------------------------

### About {#About}

<!-- {data-width=500} -->
<p style='text-align:justify;'>This dashboard provides a set of interactive visualizations focused on the prosperity gap and associated indicators.</p>

<p style='text-align:justify;'>The estimates are based on country-level household survey unit record data or grouped data. Survey data are the most widely available source of information on distributions of income or consumption. However, research on some countries has shown that surveys tend to underestimate the income of the richest, for which no corrections have been made in these estimates. </p>

<p style='text-align:justify;'>From the survey, a measure of household welfare is constructed, capturing either household income or consumption. There are important differences between the two concepts; in particular, inequality in incomes is systematically greater than inequality in consumption. Countries in Europe and Central Asia, Latin America and the Caribbean, the Other High Income group tend to use income surveys, while the rest of the world uses consumption. Users are advised to take these differences into account, especially when comparing levels of inequality across countries and regions.</p>

<p style='text-align:justify;'>Changes in questionnaire design imply that estimates of poverty and inequality within countries become incomparable. Whenever such changes occur, a break is shown in the trend trend. The visualization of changes over time only includes countries that have a [comparable](https://datanalytics.worldbank.org/PIP-Methodology/welfareaggregate.html#comparability) survey spell over the period chosen.</p>

<p style='text-align:justify;'>The term country, used interchangeably with economy, does not imply political independence but refers to any territory for which authorities report separate social or economic statistics.</p>

<p style='text-align:justify;'>For more details on the methodology, please visit the [PIP Methodology Handbook](https://datanalytics.worldbank.org/PIP-Methodology/) and the [Global Poverty Monitoring Technical Notes](https://pip.worldbank.org/publication). For any questions regarding the data or methodology, please contact pip@worldbank.org.</p>

<p style='text-align:justify;'>Please cite the data as:  `r paste(source_text)`. Accessed `r today()`. </p>




### Definitions {#Definitions}

<span class="underline">Inequality indicators:</span>

\newline
<p style='text-align:justify;'> </p>

<span class="underline">Other variables:</span>

\newline

<p style='text-align:justify;'>

The **Year** variable is the starting year of the household survey. In some countries, the data collection spans multiple years. When looking at changes over time, users can select **circa years** (i.e., a window around the chosen year). This increases the sample of countries available, since not all countries have annual household surveys, as explained in more detail on the chart page.</p>

<p style='text-align:justify;'>Countries can also be grouped by **region**. The dashboard uses PIP’s [regional definition](https://datanalytics.worldbank.org/PIP-Methodology/lineupestimates.html#regionsandcountries) which differs from the regional classifications used by the World Bank. Some high-income economies are excluded from the geographical regions and are included as a separate group referred to as “other high income”.</p>





